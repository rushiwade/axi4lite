`timescale 1ns/1ps

// ============================= AXI4-Lite interface (TB-internal) =============================
interface axi4lite_if #(
  parameter int ADDR_W = 32,
  parameter int DATA_W = 32
);
  // Write address
  logic                  awvalid;
  logic                  awready;
  logic [ADDR_W-1:0]     awaddr;

  // Write data
  logic                  wvalid;
  logic                  wready;
  logic [DATA_W-1:0]     wdata;
  logic [(DATA_W/8)-1:0] wstrb;

  // Write response
  logic                  bvalid;
  logic                  bready;
  logic [1:0]            bresp;

  // Read address
  logic                  arvalid;
  logic                  arready;
  logic [ADDR_W-1:0]     araddr;

  // Read data
  logic                  rvalid;
  logic                  rready;
  logic [DATA_W-1:0]     rdata;
  logic [1:0]            rresp;
endinterface

// ============================= SVA to bind to slave =============================
`ifndef SYNTHESIS
// synthesis translate_off
module axi4lite_sva #(
  parameter int ADDR_W = 32,
  parameter int DATA_W = 32,
  parameter int HS_MAX = 16
)(
  axi4lite_if axi,
  input  logic clk,
  input  logic rst_n
);
  // AW handshake
  property p_aw_hs;
    @(posedge clk) disable iff (!rst_n)
      axi.awvalid |-> ##[1:HS_MAX] axi.awready;
  endproperty
  assert property (p_aw_hs) else $error("AW handshake timeout");

  // W handshake
  property p_w_hs;
    @(posedge clk) disable iff (!rst_n)
      axi.wvalid |-> ##[1:HS_MAX] axi.wready;
  endproperty
  assert property (p_w_hs) else $error("W handshake timeout");

  // Write completes -> BVALID
  sequence s_write_done;
    axi.awvalid && axi.awready ##0 axi.wvalid && axi.wready;
  endsequence

  property p_b_after_write;
    @(posedge clk) disable iff (!rst_n)
      s_write_done |-> ##[1:HS_MAX] axi.bvalid;
  endproperty
  assert property (p_b_after_write) else $error("No BVALID after write");

  // BRESP OKAY
  property p_bresp_okay;
    @(posedge clk) disable iff (!rst_n)
      axi.bvalid |-> (axi.bresp == 2'b00);
  endproperty
  assert property (p_bresp_okay) else $error("BRESP not OKAY");

  // AR handshake
  property p_ar_hs;
    @(posedge clk) disable iff (!rst_n)
      axi.arvalid |-> ##[1:HS_MAX] axi.arready;
  endproperty
  assert property (p_ar_hs) else $error("AR handshake timeout");

  // R handshake
  property p_r_hs;
    @(posedge clk) disable iff (!rst_n)
      axi.rvalid |-> ##[0:HS_MAX] axi.rready;
  endproperty
  assert property (p_r_hs) else $error("R handshake timeout");
endmodule
// synthesis translate_on
`endif

// ============================= Testbench top ===================================
module tb_axi_master_slave;

  localparam int ADDR_W = 32;
  localparam int DATA_W = 32;

  logic clk;
  logic rst_n;

  // TB-local AXI bus (used to drive/wire DUT)
  axi4lite_if #(.ADDR_W(ADDR_W), .DATA_W(DATA_W)) axi();

  // ---- Clock & Reset ----
  initial begin
    clk = 1'b0;
    forever #5 clk = ~clk; // 100 MHz
  end

  initial begin
    rst_n = 1'b0;
    // Safe defaults
    axi.awvalid = 1'b0;
    axi.wvalid  = 1'b0;
    axi.bready  = 1'b0;
    axi.arvalid = 1'b0;
    axi.rready  = 1'b0;
    axi.awaddr  = '0;
    axi.wdata   = '0;
    axi.wstrb   = '0;
    axi.araddr  = '0;
    #50;
    rst_n = 1'b1;
  end

  // ================== DUTs ==================
  // Master (ports: aclk/aresetn)
  axl_master u_master (
    .aclk    (clk),
    .aresetn (rst_n),

    .awaddr  (axi.awaddr),
    .awvalid (axi.awvalid),
    .awready (axi.awready),

    .wdata   (axi.wdata),
    .wvalid  (axi.wvalid),
    .wready  (axi.wready),

    .bresp   (axi.bresp),
    .bvalid  (axi.bvalid),
    .bready  (axi.bready),

    .araddr  (axi.araddr),
    .arvalid (axi.arvalid),
    .arready (axi.arready),

    .rdata   (axi.rdata),
    .rresp   (axi.rresp),
    .rvalid  (axi.rvalid),
    .rready  (axi.rready)
  );

  // Slave (ports: aclk/aresetn) â€” NO wstrb in this RTL
  a4l_slave u_slave (
    .aclk    (clk),
    .aresetn (rst_n),

    // Write address
    .awaddr  (axi.awaddr),
    .awvalid (axi.awvalid),
    .awready (axi.awready),

    // Write data
    .wdata   (axi.wdata),
    .wvalid  (axi.wvalid),
    .wready  (axi.wready),

    // Write response
    .bresp   (axi.bresp),
    .bvalid  (axi.bvalid),
    .bready  (axi.bready),

    // Read address
    .araddr  (axi.araddr),
    .arvalid (axi.arvalid),
    .arready (axi.arready),

    // Read data
    .rdata   (axi.rdata),
    .rresp   (axi.rresp),
    .rvalid  (axi.rvalid),
    .rready  (axi.rready)
  );

  // ================== Simple BFM ==================
  task automatic axi_write(input logic [ADDR_W-1:0] addr,
                           input logic [DATA_W-1:0] data,
                           input logic [(DATA_W/8)-1:0] strb = {(DATA_W/8){1'b1}});
    @(posedge clk);
    axi.awaddr  <= addr;
    axi.awvalid <= 1'b1;

    axi.wdata   <= data;
    axi.wstrb   <= strb;     // unused by slave RTL; harmless
    axi.wvalid  <= 1'b1;

    wait (axi.awready);
    @(posedge clk);
    axi.awvalid <= 1'b0;

    wait (axi.wready);
    @(posedge clk);
    axi.wvalid  <= 1'b0;

    axi.bready  <= 1'b1;
    wait (axi.bvalid);
    $display("[%0t] WRITE 0x%08h <= 0x%08h (BRESP=%0d)", $time, addr, data, axi.bresp);
    @(posedge clk);
    axi.bready  <= 1'b0;
  endtask

  task automatic axi_read(input  logic [ADDR_W-1:0] addr,
                          output logic [DATA_W-1:0] data);
    @(posedge clk);
    axi.araddr  <= addr;
    axi.arvalid <= 1'b1;

    wait (axi.arready);
    @(posedge clk);
    axi.arvalid <= 1'b0;

    axi.rready  <= 1'b1;
    wait (axi.rvalid);
    data = axi.rdata;
    $display("[%0t] READ  0x%08h => 0x%08h (RRESP=%0d)", $time, addr, data, axi.rresp);
    @(posedge clk);
    axi.rready  <= 1'b0;
  endtask

  // ================== Stimulus ==================
  initial begin : stim
    logic [DATA_W-1:0] r;

    wait (rst_n);
    repeat (5) @(posedge clk);

    axi_write(32'h0000_0010, 32'hDEAD_BEEF);
    axi_read (32'h0000_0010, r);

    if (r !== 32'hDEAD_BEEF)
      $error("Readback mismatch: expected 0xDEADBEEF, got 0x%08h", r);
    else
      $display("[%0t] Readback OK", $time);

    repeat (20) @(posedge clk);
    $display("Simulation Complete");
    $finish;
  end

  // ================== Bind SVA to the slave ==================
`ifndef SYNTHESIS
// synthesis translate_off
  bind a4l_slave axi4lite_sva #(.ADDR_W(ADDR_W), .DATA_W(DATA_W))
    u_axi4lite_sva (.axi(axi), .clk(clk), .rst_n(rst_n));
// synthesis translate_on
`endif

endmodule
